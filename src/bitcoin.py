# -*- coding: utf-8 -*-
"""Bitcoin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y6dtRGPzMPblBwlx5lT8aV60PFKsVHjA

#Social Network Analysis with Bitcoin Alpha

It is a network of people who trade using Bitcoin on a platform called Bitcoin Alpha.In this network there is a need to maintain a record of users' reputation to prevent transactions with fraudulent and risky users.

#### First Step with Bitcoin Alpha

First,we have to find the apporopriate dataset for network analysis.And after finding,we have to check whether its CSV or Zip File.

Suppose Zip File,we have use the code to unzip the File as shown below.

Else we can directly proceed to next step.
"""

# !gzip -d /content/soc-sign-bitcoinalpha.csv.gz

"""After Unzipping the File, We can use this code to show data or information from CSV File as shown below."""

# !head /content/soc-sign-bitcoinalpha.csv

"""### Import the Library Package"""
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
# Commented out IPython magic to ensure Python compatibility.
import pandas as pd

# Show matplotlib charts in cells
# %matplotlib inline

"""### Read CSV File

Here, We are Using Pandas **(pd)** to Read **CSV File** which we have unzipped.We are defining header as 2 columns.And we are specifying the names for headers as 'ONE','TWO'.Finally we are giving Number of Rows(nrows) as 1500 upto the data will be displayed.
"""

data = pd.read_csv('data/soc-sign-bitcoinalpha.csv', sep=',', header=2, names=['SRC', 'DST'], nrows=1500)

"""Here we can see sample output of data from CSV File with Header Names as defined in code above and with limit of 10 rows as defined below in the code.You can set the limit by using the below code."""

data.head(10)

"""Here,we used to create a graph using bitcoin. 

from_pandas_edgelist which returns a graph from Pandas DataFrame containing an edge list.

DiGraph is a Directed Graph. This can be modeled by means of an undirected graph, therefore we use the Graph class to construct our bitcoin object with our header names.

### Bitcoin Alpha into Undirected Graph
"""

bitcoin = nx.from_pandas_edgelist(data, 'SRC', 'DST', create_using=nx.DiGraph)

"""Here,We are converting bitcoin directed graph into undirected graph.To chech Whether the graph is connected or not with file and number of connected components in the graph."""

bitcoin_undirected = bitcoin.to_undirected()

"""We have print the connected graph and number of connected components in bitcoin Alpha."""

print('The graph {} connected.'.format('is' if nx.is_connected(bitcoin_undirected) else 'is not'))
print('Number of connected components:', nx.number_connected_components(bitcoin_undirected))

"""As,we used connected components as shown above, here we enumerating the connected components with index value and adding 1 for each components.As the results is shown below."""

connected_components = nx.connected_components(bitcoin_undirected)
for index, component in enumerate(connected_components):
    print(f"Component {index + 1}: {component}")

"""### Largest connected components in Bitcoin

We are Checking Largest connected component for bitcoin undirected. 

First We have print the number of nodes in the graph with largest connected component in graph.

Then Density of largest connected node using the code nx.density and LCC(Bitcoin Undirected Graph with Largest connceted components in graph).
"""

largest_cc = max(nx.connected_components(bitcoin_undirected), key=len)

print("Number of nodes in the largest connected component:", len(largest_cc))

LCC = bitcoin_undirected.subgraph(largest_cc)
print("Density of the largest connected component:", nx.density(LCC))

"""### Density

Here we are print the Density of Bitcoin Graph.
"""

print('Density of G:', nx.density(bitcoin))

"""### Centrality

In Centrality, who is more important to network. Degree centrality is the simplest measure of node connectivity. 

As how many direct connections for each node has to other nodes in the network.Here we are finding the degree centrality of bitcoin network using nx.degree_centrality and print the node with centrality as shown below.
"""

print("Degree centrality")
for node, centrality in nx.degree_centrality(bitcoin).items():
    print(f'{node}:\t{centrality:.3f}')

"""#### Closeness Centrality

Closeness Centrality is a measure calculates the shortest paths between all nodes, then assigns each node a score based on its sum of shortest paths.Here we have printed 20 values from bitcoin network.
"""

print("\nCloseness centrality (sorted)")
dc = nx.degree_centrality(bitcoin)
dc_sorted = {k: v for k, v in sorted(
    dc.items(),
    key=lambda item: item[1],
    reverse=True
)[:20]}
for node, centrality in dc_sorted.items():
    print(f'{node}:\t{centrality:.3f}')

"""#### In Degree Centrality

In-degree Centrality which is number of inbound links as distinct measures, when looking at transactional data or account activity. we have printed 20 values from bitcoin network.
"""

print("In-degree centrality")
in_dc = nx.in_degree_centrality(bitcoin)
in_dc_sorted = {k: v for k, v in sorted(
    in_dc.items(),
    key=lambda item: item[1],
    reverse=True
)[:20]}
for node, centrality in in_dc_sorted.items():
    print(f'{node}:\t{centrality:.3f}')

"""#### Out Degree Centrality

Out Degree Centrality is number of outbound links as distinct measures. we have printed 20 values from bitcoin network.
"""

print("\nOut-degree centrality")
out_dc = nx.out_degree_centrality(bitcoin)
out_dc_sorted = {k: v for k, v in sorted(
    out_dc.items(),
    key=lambda item: item[1],
    reverse=True
)[:20]}
for node, centrality in out_dc_sorted.items():
    print(f'{node}:\t{centrality:.3f}')

"""##### Hubs

Hubs which estimates the node value based on outgoing links.We have print 3 values from bitcoin Network.
"""

# Hubs and authorities (let's take the first three)

hubs = sorted(
    bitcoin.out_degree,
    key=lambda x: x[1],
    reverse=True
)[:3]

print('Hubs:', hubs, end='\n\n')

"""##### Authorities

Authorities estimates the node value based on the incoming links.We have print 3 values from bitcoin Network.
"""

authorities = sorted(
    bitcoin.in_degree,
    key=lambda x: x[1],
    reverse=True
)[:3]
print('Authorities:', authorities)

"""#### Closeness Centrality

Here we can see it calculates the shortest paths between all nodes, then assigns each node a score based on its sum of shortest paths.
"""

closeness = nx.closeness_centrality(bitcoin)
cores = sorted(closeness.items(), key=lambda x: x[1], reverse=True)[:10]
print(cores)

"""#### Betweenness Centrality

Here it shows which nodes are ‘bridges’ between nodes in a network. It identify all the shortest paths and then counts the number of times each node falls on one.
"""

print("Betweenness centrality")
for node, centrality in nx.betweenness_centrality(bitcoin).items():
    print(f'{node}:\t{centrality:.3f}')

print("\nBetweenness centrality (normalized)", )
for node, centrality in nx.betweenness_centrality(bitcoin, normalized=True).items():
    print(f'{node}:\t{centrality:.3f}')

print("\nBetweenness centrality (sorted)")
bc = nx.betweenness_centrality(bitcoin)
bc_sorted = {k: v for k, v in sorted(
    bc.items(),
    key=lambda item: item[1],
    reverse=True
)[:10]}
for node, centrality in bc_sorted.items():
    print(f'{node}:\t{centrality:.3f}')

"""##### Gatekeepers

Gatekeepers hold a critical position between other nodes that are not directly linked and thus, in a network, they are nodes that provide a connection, and serve as a bridge.

It has highest betweenness Centrality.
"""

gatekeepers = sorted(nx.betweenness_centrality(bitcoin).items(), key=lambda x: x[1], reverse=True)[:3]

print("Network gatekeepers:")

for gatekeeper in gatekeepers:
    print(gatekeeper)

"""### Cliques

A clique is a sub-set of a network in which the nodes are more closely and intensely tied to one another than they are to other nodes of the network.The clique number of a graph is the size of the largest clique in the graph.

While we have imported approximation,clique from networkx.algorithms and then find the number of maximal cliques in the graph.Next,Print All the cliques in the network based on find of Undirected Bitcoin.
"""

from networkx.algorithms import clique

# Find the number of maximal cliques in the graph
n_of_cliques = clique.graph_number_of_cliques(bitcoin_undirected)
print("Number of cliques in the network:", n_of_cliques, end='\n\n')

# Print all the cliques
all_cliques = clique.find_cliques(bitcoin_undirected)
print("All the cliques in the network:")
for c in all_cliques:
    print(c)

"""### Ego Graph

Ego networks are the network is based off the ego and all other nodes directly connected to the ego are called alters.And is used to analyze the ties among those alters.

Here, ego and gk_ego were defining the cores and nx.ego_graph for bitcoin network.
"""

ego = cores[0][0]
gk_ego = nx.ego_graph(bitcoin, ego)

"""As we are drawing the final network graph using the previous section ego and gk_ego variable. Declaring Pos(Position), to  layout for gk_ego. And plt.title as Title for the graph. And using nx.draw for gk_ego which have seen in pervious code and adding the color,size for node. Finally we can see Ego Network by using plt.show()."""

# Draw graph
pos = nx.spring_layout(gk_ego)
plt.title("Ego Network")
nx.draw(gk_ego, pos, node_color='r', node_size=20, with_labels=False)
nx.draw_networkx_nodes(gk_ego, pos, nodelist=[ego], node_size=200, node_color='y')
plt.show()
